# Scope Proposal & Explainer

<!-- generated by VSCode Markdown All-In-One extension -->

- [Authors](#authors)
- [Participate on CSSWG threads](#participate-on-csswg-threads)
- [Introduction](#introduction)
- [Goals](#goals)
  - [The namespace problem](#the-namespace-problem)
  - [The nearest-ancestor "proximity" problem](#the-nearest-ancestor-proximity-problem)
  - [The lower-boundary, or "ownership" problem (aka "donut scope")](#the-lower-boundary-or-ownership-problem-aka-donut-scope)
  - [Popular tooling for modular CSS](#popular-tooling-for-modular-css)
- [Non-goals](#non-goals)
- [Proposed Solution](#proposed-solution)
  - [Re-introducing the `@scope` rule](#re-introducing-the-scope-rule)
  - [The (existing) `:scope` pseudo-class](#the-existing-scope-pseudo-class)
  - [A new donut selector?](#a-new-donut-selector)
  - [Scope in the cascade](#scope-in-the-cascade)
    - [Specificity](#specificity)
    - [Scope Proximity](#scope-proximity)
- [Key scenarios](#key-scenarios)
  - [Avoid naming conflicts without custom conventions](#avoid-naming-conflicts-without-custom-conventions)
  - [Express ownership boundaries in nested components](#express-ownership-boundaries-in-nested-components)
  - [Recursive nesting with ownership](#recursive-nesting-with-ownership)
  - [Recognizing proximity of nested components without lower-bounds](#recognizing-proximity-of-nested-components-without-lower-bounds)
  - [JS tools & "single file components"](#js-tools--single-file-components)
- [Detailed design discussion & alternatives](#detailed-design-discussion--alternatives)
  - [Is there a global `:scope` selector?](#is-there-a-global-scope-selector)
  - [Are scope attributes useful in html?](#are-scope-attributes-useful-in-html)
  - [Should we be building on Shadow DOM?](#should-we-be-building-on-shadow-dom)
  - [Do we need special handling around the shadow-DOM?](#do-we-need-special-handling-around-the-shadow-dom)
  - [What selectors can be used to describe a scope root?](#what-selectors-can-be-used-to-describe-a-scope-root)
  - [Should we have a selector syntax for lower boundaries?](#should-we-have-a-selector-syntax-for-lower-boundaries)
  - [A JS API for fetching "donut scope" elements?](#a-js-api-for-fetching-donut-scope-elements)
  - [How does scope interact with the nesting module?](#how-does-scope-interact-with-the-nesting-module)
  - [Can scope rules be nested in other scope rules?](#can-scope-rules-be-nested-in-other-scope-rules)
  - [Where does scope fit in the cascade?](#where-does-scope-fit-in-the-cascade)
    - [The 2014 scope proposal](#the-2014-scope-proposal)
    - [Shadow-DOM encapsulation context](#shadow-dom-encapsulation-context)
    - [The case for less isolation, and weak proximity](#the-case-for-less-isolation-and-weak-proximity)
    - [Additional specificity](#additional-specificity)
  - [Can we improve on the syntax?](#can-we-improve-on-the-syntax)
- [Spec History & Context](#spec-history--context)
  - [CSS Scoping](#css-scoping)
  - [CSS Selectors - Level 4](#css-selectors---level-4)
  - [CSS Cascade - Level 4](#css-cascade---level-4)
- [Stakeholder Feedback / Opposition](#stakeholder-feedback--opposition)
- [References & acknowledgements](#references--acknowledgements)
- [To Be Addressed](#to-be-addressed)
- [Change log](#change-log)
  - [2021.01.28](#20210128)
  - [2021.01.27](#20210127)
  - [2021.01.18](#20210118)

## Authors

- Miriam Suzanne

## Participate on CSSWG threads

Please leave any feedback on the CSSWG issues for this proposal:

- [Proposal for light-dom scoping/namespacing](https://github.com/w3c/csswg-drafts/issues/5809)
- [Request for TAG review](https://github.com/w3ctag/design-reviews/issues/593)

Typos or other document-specific issues
[can be reported in this repo](https://github.com/oddbird/css-sandbox/issues).

## Introduction

There are many overlapping
and sometimes contradictory features
that can live under the concept of "scope" in CSS --
but they divide roughly into two approaches:

1. Total isolation of a component DOM subtree/fragment from the host page,
   so that no selectors get in or out
   unless explicitly requested.
2. Lighter-touch component namespacing,
   and prioritization of "proximity"
   when resolving the cascade.

That has lead to a wide range of proposals over the years,
including a [scope specification][initial-spec]
that was never implemented.
Focus moved to Shadow-DOM,
which is mainly concerned with approach #1 -- full isolation.
Meanwhile authors have attempted to handle approach #2
through convoluted naming conventions (like [BEM][])
and JS tooling
(such as [CSS Modules][], [Styled Components][], & [Vue Scoped Styles][]).

This document is proposing a native CSS approach
for what many authors are already doing
with those third-party tools & conventions.

[initial-spec]: https://www.w3.org/TR/css-scoping-1/
[BEM]: http://getbem.com/
[CSS Modules]: https://github.com/css-modules/css-modules
[Styled Components]: https://styled-components.com/
[Vue Scoped Styles]: https://vue-loader.vuejs.org/guide/scoped-css.html

## Goals

### The namespace problem

All CSS Selectors are global,
matching against the entire DOM.
As projects grow,
or adapt a more modular "component-composition" approach,
it can be hard to track what names have been used,
and avoid conflicts.

To solve this,
authors rely on
convoluted naming conventions (BEM)
and JS tooling (CSS Modules & Scoped Styles)
to "isolate" selector matching inside a single "component".

BEM helps authors by ensuring that only
component "blocks" need unique naming:

```css
.media { /* block */ }
.tabs { /* block */ }
```

Meanwhile,
any internal "elements" or "modifiers"
will be scoped to the block:

```css
.media--reverse { /* modifier */ }
.media__img { /* element */ }
.media__text { /* element */ }

.tabs--left { /* modifier */ }
.tabs__list { /* element */ }
.tabs__panel { /* element */ }
```

### The nearest-ancestor "proximity" problem

Ancestor selectors allow us to
filter the "scope" of nested selectors
to a sub-tree in the DOM:

```css
/* link colors for light and dark backgrounds */
.light-theme a { color: purple; }
.dark-theme a { color: plum; }
```

But problems show up quickly
when you start thinking of these as modular styles
that should nest in any arrangement.

```html
<div class="dark-theme">
  <a href="#">plum</a>

  <div class="light-theme">
    <a href="#">also plum???</a>
  </div>
</div>
```

Our selectors appropriately have the same specificity,
but they are not weighted by
"proximity" to the element being styled.
Instead we fallback to source order,
and `.dark-theme` will always take precedence.

There is no selector/specificity solution
that accurately reflects what we want here --
with the "nearest ancestor" taking precedence.

This was one of the
[original issues highlighted by OOCSS][oocss-proximity]
in 2009.

[oocss-proximity]: https://www.slideshare.net/stubbornella/object-oriented-css/62-CSS_WISH_LIST

### The lower-boundary, or "ownership" problem (aka "donut scope")

While "proximity" is loosely concerned with nesting styles,
the problem comes into more focus
with the concept of modular components --
which can be more complex.

To use BEM terminology,
Components are generally comprised of:

- An outer "block" or component wrapper
- Inner "elements" that belong to that block explicitly
- Occasional "donut holes" or "slots" where sub-components can be nested

In html templating languages,
and JS frameworks,
this can be represented by an "include"
or "single file component".

BEM attempts to convey this "ownership" in CSS:

```css
/* any title inside the component tree */
.component .title { /* too broad */ }

/* only a title that is a direct child of the component */
.component > .title { /* too limiting of DOM structures */ }

/* just the title of the component */
.component__title { /* just right? */ }
```

Nicole Sullivan coined the term
["donut" scope][donut] for this issue in 2011 --
because the scope can have a hole in the middle.
It would be useful for authors
to express this DOM-fragment
"ownership" more clearly in native HTML/CSS.

[donut]: http://www.stubbornella.org/content/2011/10/08/scope-donuts/

### Popular tooling for modular CSS

CSS Modules, Vue, Styled-JSX, and other tools
often use a similar pattern
(with slight variations to syntax) --
where "scoped" selectors only apply to
the locally described DOM fragment,
and not descendants.

In Vue single file components,
authors can write html templates
with "scoped" style blocks:

```html
<!-- component.vue -->
<template>
  <section class="component">
    <div class="element">...<div>
    <sub-component>...</sub-component>
  </section>
</template>

<style scoped>
.component { /* ... */ }
.element { /* ... */ }
.sub-component { /* ... */ }
</style>

<!-- sub-component.vue -->
<template>
  <section class="sub-component">
    <div class="element">...<div>
  </section>
</template>

<style scoped>
.sub-component { /* ... */ }
.element { /* ... */ }
</style>
```

While the language is similar to shadow-DOM in many ways,
the output is quite different --
and much less isolated.
The components remain part of the global scope,
and only the explicitly "scoped" styles are contained.
That's often achieved by automatically adding unique attributes
to each element based on the component(s) it belongs to:

```html
<section class="component" scope="component">
  <div class="element" scope="component">...<div>

  <!-- nested component "shell" is in both scopes -->
  <section class="sub-component" scope="component sub-component">
    <div class="element" scope="sub-component">...<div>
  </section>
</section>
```

And matching attributes are added to each selector:

```css
/* component.vue styles after scoping */
.component[scope=component] { /* ... */ }
.element[scope=component] { /* ... */ }
.sub-component[scope=component] { /* ... */ }

/* sub-component.vue styles after scoping */
/* note that both style `.element` without any overlap or naming conflicts */
.sub-component[scope=sub-component] { /* ... */ }
.element[scope=sub-component] { /* ... */ }
```

- The donut is achieved by selectively adding attributes
- Proximity-weight is achieved only through limiting the donut of scope,
  so that outer values are less likely to "bleed" in
- Added attribute gives scoped styles _some_ (but very little)
  extra specificity weight in the cascade

## Non-goals

There is a more extreme isolation use-case.
It's mostly used for "widgets" that will appear unchanged
across multiple projects --
but sometimes also in component libraries
on larger projects.

Full isolation blocks off a fragment of the DOM,
so that it _only_ accepts styles that are
explicitly scoped.
General page styles do not apply.

I don't think this is the most common concern for authors,
but it has received the most attention.
Shadow DOM is entirely constructed around this behavior.

I have not attempted to address that form of scope in my proposal --
it feels like a significantly different approach
that already has work underway.

See Yu Han's proposals for
[building on shadow DOM](#should-we-be-building-on-shadow-dom)
below.

## Proposed Solution

### Re-introducing the `@scope` rule

_This would likely belong in
the [CSS Scoping Module](https://drafts.csswg.org/css-scoping/)._

In the long-standing
["Bring Back Scope"](https://github.com/w3c/csswg-drafts/issues/3547)
issue-thread,
Giuseppe Gurgone
[suggests a syntax](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-524206816) building on the original un-implemented `@scope` spec,
but adding a lower boundary:

```css
@scope (from: .carousel) and (to: .carousel-slide-content) {
  p { color: red }
}
```

I think that's a good place to start.
In my mind, the first ("from") clause should be required,
and may not need explicit labeling.
It would accept a single (complex) selector:

```css
@scope (.media-block) {
  img { border-radius: 50%; }
}
```

In terms of selector-matching,
this would be the same as
`.media-block img`,
but with slightly different cascade implications
([see cascade section](#scope-proximity-in-the-cascade)).

The second ("to") clause would be optional,
and accept a list of selectors
that represent lower-boundary "slots" in the scope.
The targeted lower-boundary elements are included in the scope,
but their descendants are not:

```css
@scope (.media-block) to (.content) {
  img { border-radius: 50%; }
  .content { padding: 1em; }
}
```

Which would only match `img` and `.content`
inside `.media-block` --
_but not if there is no intervening `.content`
between the scope root and selector target_:

```html
<div class="media-block">
  <img src="..."><!-- this img is in the .media-block scope -->
  <div class="content"><!-- this .content is in-scope -->
    <img src="..."><!-- this img is NOT -->
    <div class="more content">...</div><!-- this .content is NOT -->
  </div>
</div>
```

This approach keeps scoping confined to CSS
(no need for an HTML attribute),
flexible
(scopes can overlap as needed),
and low-impact
(global styles continue to work as expected).
Existing tools would still be able to
provide syntax sugar for single-file components --
automatically generating the from/to clauses --
but move the primary functionality into CSS.

### The (existing) `:scope` pseudo-class

In most cases we can infer
that the `@scope` root selector
is prepended to all internal selectors
with an ancestor/descendant relationship:

```css
@scope (.media) {
  img { /* .media img */ }
  .content { /* .media .content */ }
}
```

There is even an existing
[Reference Element Pseudo-class][scope-class]
(`:scope` selector),
which we can use to represent that behavior.
It is currently supported in JS APIs
to refer to the base element of e.g. `element.querySelector()`.
The following blocks would be identical:

```css
@scope (.media) {
  img { /* .media img */ }
  .content { /* .media .content */ }
}

@scope (.media) {
  :scope img { /* .media img */ }
  :scope .content { /* .media .content */ }
}
```

Authors can also use `:scope`
to express more complex relationships
between a scoped selector and the scope-root.
For example, adding an explicit combinator:

```css
@scope (.media) {
  :scope > img { object-fit: cover; }
}
```

Or adding contextual information outside the scope:

```css
@scope (.media) {
  .sidebar :scope img { object-fit: cover; }
}
```

Or styling the scope-root directly:

```css
@scope (.media) {
  :scope { display: grid; }
}
```

This is especially useful
if we want to target a nested instance
of the scope root selector:

```css
@scope (.media) {
  /* select only the scope-root .media  */
  :scope { display: grid; }

  /* select nested .media inside the scope */
  .media { background: gray; }
  :scope .media { background: gray; }
}
```

Since there is no way
to have the root element inside itself,
we would not support nested instances of `:scope` itself:

```css
@scope (.media) {
  /* no match */
  :scope :scope { background: gray; }
  :scope + :scope { background: gray; }
}
```

Note: There has also been some discussion
of using the [nesting module][nesting]
`&` nested-selector for this.
But `&` acts as an alias for duplicating a selector list,
while `:scope` refers to a specific element
that is acting as the root of a given context.
Given the likelihood that
nesting and scope will be used together,
it seemed important that these ideas remain distinct.

### A new donut selector?

Lea Verou has pointed out
that it might be useful for authors
to access "donut-matching" as a distinct feature,
apart from the cascade rules of scoping.

That could be done with a pseudo-selector
(name to-be-determined)
akin to `:is()` or `:not()`.
This new selector would need to describe the entire donut,
taking two arguments:
a root selector,
and lower-boundary selector.
Since spaces and commas exist inside selectors,
we could borrow the slash as a delimiter.
Imagine a syntax like:

```css
/* :in(<selector> / <selector>) */
:in(.root .selector / .lower .boundary)
```

The following selectors
would match the same elements:

```css
@scope (.media) to (.content) {
  img { border: red; }
}

img:in(.media / .content) { border: red; }
```

### Scope in the cascade

The `@scope` rule has a double-impact
on the cascade of scoped selectors --
as part of specificity,
and then again in relation to proximity.

At first that seemed potentially confusion,
but after many conversations,
I think it may be the most expected behavior.

#### Specificity

It seems to me that `@scope`,
a donut-pseudo-class like `:in()`,
and explicit use of `:scope`
should all have matching specificity.

Existing CSS-in-JS tools
often add a single attribute to achieve scope.
We could achieve the same result
by relying on the default weight of pseudo-class selectors.
All the following would have
an (ID, class, element) specificity of `(0, 2, 0)`:

```css
@scope (#tabs) to (.panel) {
  /* implied ancestor :scope */
  .tab-item { /* ... */ }
  /* explicit :scope */
  :scope .tab-item { /* ... */ }
  .sidebar :scope { /* ... */ }
}

.tab-item:in(#tabs / .panel) { /* ... */ }
```

Alternatively,
we could attempt to
follow the [nesting module][nesting] approach:
with scope-root considered a part
of any scoped selector's specificity.
That would mean giving both `:scope` and `:in()`
the specificity of the root selector,
resulting in a specificity of `(1, 1, 0)`
for the examples above.

#### Scope Proximity

_This would likely belong in
[CSS Cascading & Inheritance](https://drafts.csswg.org/css-cascade/)._

The syntax above solves the issue of
naming-conflicts, with lower-boundaries/ownership.
But the issue of _scope proximity_ requires changes in the Cascade.
My sense is that scope proximity
should override _source order_,
but otherwise cascade layers & specificity
should take precedence.

Given the same origin & importance, layering, and specificity --
inner "more proximate" scope would take precedence
over outer/global "less proximate" scopes:

```css
@scope (.light-theme) {
  a { color: purple; }
}

@scope (.dark-theme) {
  a { color: plum; }
}
```

```html
<div class="dark-theme">
  <a href="#">plum</a>

  <div class="light-theme">
    <a href="#">purple</a>
  </div>
</div>
```

Given the same proximity of multiple scopes,
source order would continue to be the final cascade filter:

```css
@scope (.light-theme) {
  a { color: purple; }
}

@scope (.special-links) {
  a { color: maroon; }
}
```

```html
<div class="special-links light-theme">
  <a href="#">maroon</a>
</div>
```

However, in this proposal
**specificity can override scope proximity**.
Given the following CSS,
a paragraph matched by both rules
would be `red`,
thanks to the added specificity:

```css
@scope aside {
 p { color: green; }
}

aside#sidebar p { color: red; }
```

This is a major departure from both
the [original scope specification][initial-spec]
and Shadow-DOM [encapsulation context][],
which override specificity.
That is useful in certain cases,
but many authors desire a lighter-touch scope --
allowing global styles to easily flow through scoped components,
while preventing scoped styles from leaking out.

I [discuss this in more detail below](#where-does-scope-fit-in-the-cascade).

## Key scenarios

### Avoid naming conflicts without custom conventions

Authors currently rely on intricate naming conventions
to avoid duplicate naming within components:

```css
.article__title {
  font-size: 2em;
}
.article__meta {
  font-size: 2em;
}

.form__title {
  font-weight: bold;
}
.form__meta {
  font-weight: bold;
}
```

Sometimes authors will automate that process,
and group names visually,
using nested syntax in a pre-processor like Sass:

```scss
.article {
  &__title { font-size: 2em; }
  &__meta { font-style: italic; }
}

.form {
  &__title { font-weight: bold; }
  &__meta { text-align: center; }
}
```

This syntax would provide a uniform solution
that is native to CSS.
Authors can reduce naming conflicts
across CSS "components"/"objects"
by scoping internal selectors
so they only match within a particular block:

```css
@scope (article) {
  .title { font-size: 2em; }
  .meta { font-style: italic; }
}

@scope (form) {
  .title { font-weight: bold; }
  .meta { text-align: center; }
}
```

### Express ownership boundaries in nested components

By adding lower boundaries or "slots" to the scope,
ownership becomes more clear
when the scopes are nested.

Using the example above,
we can allow comment forms to be nested inside articles
while continuing to maintain the
distinction between article-elements
and form-elements:

```css
@scope (article) to (.comments) {
  .title { font-size: 2em; }
  .meta { font-style: italic; }
}

@scope (form) {
  .title { font-weight: bold; }
  .meta { text-align: center; }
}
```

### Recursive nesting with ownership

This can also be useful
when applying modifiers to components
that might nest indefinitely --
such as the popular "media-object"
containing a fixed image and responsive content
that flows around it.
Modifiers can be added to an outer component
without impacting nested components of the same type.

For example,
nested "media objects"
of different types:

```html
<div class="media reverse">
  <img src="...">
  <div class="content">
    <div class="media">
      <img src="...">
      <div class="content">
      </div>
    </div>
  </div>
</div>
```

Rather than adding the `.reverse` modifier
to every element in the outer media block,
we can scope the effects of the modifier:

```css
@scope (.media) to (.content) {
  /* only the inner image */
  :scope:not(.reverse) img { margin-right: 1em; }

  /* only the outer image */
  :scope.reverse img { margin-left: 1em; }
}
```

### Recognizing proximity of nested components without lower-bounds

As [demonstrated above](#scope-proximity-in-the-cascade),
authors could establish
scope precedence
even when lower bounds are not required.
For example,
light and dark themes
that can be nested
in any arrangement:

```css
@scope (.light-theme) {
  a { color: purple; }
}

@scope (.dark-theme) {
  a { color: plum; }
}
```

```html
<div class="dark-theme">
  <a href="#">plum</a>

  <div class="light-theme">
    <a href="#">purple</a>

    <div class="dark-theme">
      <a href="#">plum again</a>
    </div>
  </div>
</div>
```

### JS tools & "single file components"

Existing tools could move to automating
this syntax over time,
rather than using custom attributes,
since the result is very similar.
Without any changes visible to the user,
output that currently looks like:

```css
/* component.vue styles after scoping */
.component[scope=component] { /* ... */ }
.element[scope=component] { /* ... */ }
.sub-component[scope=component] { /* ... */ }

/* sub-component.vue styles after scoping */
/* note that both style `.element` without any overlap or naming conflicts */
.sub-component[scope=sub-component] { /* ... */ }
.element[scope=sub-component] { /* ... */ }
```

Could be converted to:

```css
/* component.vue styles after scoping */
@scope (.component) to (.sub-component) {
  :scope { /* ... */ }
  .element { /* ... */ }
  .sub-component { /* ... */ }
}

/* sub-component.vue styles after scoping */
@scope (.sub-component) {
  :scope { /* ... */ }
  .element { /* ... */ }
}
```

## Detailed design discussion & alternatives

### Is there a global `:scope` selector?

From [Selectors Level 4](https://www.w3.org/TR/selectors-4/#the-scope-pseudo)

> ‚ÄúSpecifications intending for this pseudo-class to match specific elements
> rather than the document‚Äôs root element
> must define either a scoping root (if using scoped selectors)
> or an explicit set of :scope elements.‚Äù

Those two options seem exclusive to me.
Either `:scope` should select the root of each scope
(where it matches `:root` when in the global scope),
or it can refer to _all scope roots_ --
but allowing both would be problematic.

I don't see much use for the latter definition,
but find it confusing that both are allowed.

### Are scope attributes useful in html?

Yu Han's proposal (like many others)
includes a scope attribute in HTML.
That's required for the full-isolation use-case --
where elements need to opt-in or out of global page styles up-front.

But is it required or useful for less isolated use-cases?
It does come up regularly,
as a form of syntax sugar.
From [Sebastian](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-693022720):

```css
p { color: blue; }

@scope main {
  p { color: green; }
}
@scope note {
  p { color: gray; }
}
```

```html
<p>This text is blue</p>
<section scope="main">
  <p>This text is green</p>
  <div scope="note">
    <p>This text is gray</p>
  </div>
</section>
<div scope="note">
  <p>This text is gray</p>
</div>
```

The two possible advantages are:

- Scope selectors have their own namespace
- Lower boundaries could be implicit when nesting
  (which also has a flexibility downside)

It seems to me
authors could achieve the same goals manually,
without much extra code:

```css
p { color: blue; }

@scope ([data-scope=main]) to ([data-scope]) {
  p { color: green; }
}
@scope ([data-scope=note]) to ([data-scope]) {
  p { color: gray; }
}
```

```html
<p>This text is blue</p>
<section data-scope="main">
  <p>This text is green</p>
  <div data-scope="note">
    <p>This text is gray</p>
  </div>
</section>
<div data-scope="note">
  <p>This text is gray</p>
</div>
```

So I'm not convinced we need any scope attribute.

### Should we be building on Shadow DOM?

Yu Han has
an [interesting proposal][han]
in two parts,
designed to build on top of existing shadow DOM logic:

1. Allow shadow-DOM elements to opt-in to global styles
2. Allow light-DOM elements to opt-in to style isolation

[han]: https://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharinghttps://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharing

This would require a new `scoped` HTML attribute,
because that sort of isolation has to be defined
before any styles are applied.

I think those would be good to consider,
but out-of-scope (ü§∑üèª‚Äç‚ôÄÔ∏è) for this proposal.

### Do we need special handling around the shadow-DOM?

This should have no impact on existing shadow DOM behavior.
Scoped styles can be used either in light or shadow DOM.
All scopes & scoped styles continue to respect the shadow boundary,
the same as any other CSS rules.

### What selectors can be used to describe a scope root?

Given a syntax of `@scope (<selector>)`,
are we placing any restrictions on the `<selector>`?

In most cases we expect a single/simple selector to work:

```css
@scope ([data-component=tabs]) { /* ... */  }
```

Do we need to support complex selectors?

```css
@scope (.page-context [data-component=tabs]) { /* ... */ }
@scope ([data-component=tabs].horizontal) { /* ... */ }
```

I don't see any reason to restrict them,
besides an attempt to simplify the resulting code.

Getting even more complex,
is there reason to allow selector lists
in the scope-root syntax --
defining multiple roots
for a single scope block?

```css
@scope (.scope-a, .scope-b) { /* ... */ }
```

While selector lists are clearly required
for establishing lower-boundary,
it's not clear to me if there are use-cases
for the upper-boundary/scope-root.

### Should we have a selector syntax for lower boundaries?

Since the "lower-boundary" aspect of scope
is closely related to selector-matching,
my first instinct was to try and create
a selector syntax for that feature.
That could also be useful in cases
where an author wants lower-boundaries
without the addition of cascade scope.

What makes this difficult
is that selectors are meant to _match something_.
Lower boundaries aren't intended to match,
but to establish a context in which
a match is possible.

Let's start with the `@scope` syntax
described above,
and see if we can recreate it using selectors.
Here's rule we're attempting to replicate:

```css
@scope (root) to (boundary) {
  selector { /* ... */ }
}
```

We can get close to that already by using `:is()`
along with `:not()`.
This selector-string is close:

```css
selector:is(root *):not(root boundary *) {
  /* ...  */
}
```

([example on codepen][selector-pen])
[selector-pen]: https://codepen.io/mirisuzanne/pen/jOVNJoj

But that approach fails when nesting:

```html
<root>
  <selector>This is a match</selector>
  <boundary>
    <selector>This is not a match</selector>
    <root>
      <selector>This is a false negative</selector>
    </root>
  </boundary>
</root>
```

In order to work,
we need to establish that
only the most immediate `root`/`boundary`
matches are relevant.
Establishing scope makes that possible,
since `:scope` only matches
the root element of the tree:

```css
/* this should work if `root` is the scope root element */
selector:is(:scope *):not(:scope boundary *) {
  /* ...  */
}
```

While this isn't supported in plain CSS,
it does work in JS already --
where the `:scope` selector is more clearly defined.
Starting with a `root` element,
we can select everything between than root scope
and our lower boundary:

```js
const matches = root.querySelectorAll(":not(:scope boundary *)");
```

Coming back around to CSS syntax,
we could imagine a boundary-setting pseudo-class
called `:to()`,
which would work like the `to` clause of `@scope`...

```css
root:to(boundary) selector { /* ‚Ä¶ */ }
```

But that doesn't really work as a pseudo-class,
because `:to()` doesn't _match_ anything.

However,
a pseudo-class that describes the "entire donut"
would be able to match on it's own.
I've added this to the proposal above.

### A JS API for fetching "donut scope" elements?

While the existing pattern above
allows JS to match elements _within_ a donut scope,
it doesn't provide a way to
fetch the "donut" initially.

I think
the proposed `:in()` pseudo-class
would have a similar issue --
allowing us to target all or some elements in the donut,
but not to return a tree fragment of the donut itself:

```js
document.querySelectorAll(":in(root / boundary)");
```

I think a feature like this
would better be expressed
with a second "exclusions" parameter
on methods like `querySelector()` and `querySelectorAll()`:

```js
document.querySelector("root", "boundary");
```

### How does scope interact with the nesting module?

This proposal has some overlap with
the [CSS Nesting Module][nesting]
(currently an Editor's Draft).

[nesting]: https://drafts.csswg.org/css-nesting/

With the nesting syntax,
we could allow
the `@scope` rule to be nested inside
an existing selector block,
much like `@nest`,
and establish scope-root based on the outer selector.
In this case, the scope-root selector
_must be [nest-containing](https://drafts.csswg.org/css-nesting/#nest-containing)_
(have `&` somewhere in it),
with an implied value of `&`.
These three code-blocks
would have the same meaning:

```css
/* explicit scope with root */
@scope (.media) to (.content) {
  img { object-fit: cover; }
}

.media {
  /* nested scope with explicit nesting root */
  @scope (&) to (.content) {
    img { object-fit: cover; }
  }
}

.media {
  /*nested scope with implicit nesting root */
  @scope to (.content) {
    img { object-fit: cover; }
  }
}
```

### Can scope rules be nested in other scope rules?

I can imagine use-cases for nesting scope rules,
though I don't think this is currently supported anywhere.
I think we could describe a behavior
that works as expected.
Let's take, for example:

```css
@scope (.media) to (.content) {
   @scope (figure) to (figcontent) {
     img { border: red; }
   }
}
```

I believe we can achieve the desired behavior
by flattening this to a single scope,
with our `:in()` donut selector
as part of our scope root:

```css
@scope (figure:in(.media / .content)) to (figcontent) {
  img { border: red; }
}
```

### Where does scope fit in the cascade?

#### The 2014 scope proposal

The [original scope specification][initial-spec]
put scope above specificity in the cascade,
and the layering was importance-relative:

> For normal declarations the inner scope's declarations override,
> but for ''!important'' rules outer scope's override.

That would mean first
that scope takes precedence over specificity.
By default, the more locally-scoped style always wins:

In this example
from the outdated specification,
a paragraph matched by both selectors
would be green:

```css
@scope aside {
 p { color: green; }
}

aside#sidebar p { color: red; }
```

But the roles would reverse
when `!important` is used,
and the following example paragraph would be red:

```css
@scope aside {
 p { color: green !important; }
}

aside#sidebar p { color: red !important; }
```

#### Shadow-DOM encapsulation context

Shadow-DOM [encapsulation context][]
also comes above/before specificity in the cascade,
with an importance-reversal.
To quote the spec:

> When comparing two declarations
> that are sourced from different encapsulation contexts,
> then for normal rules the declaration from the outer context wins,
> and for important rules the declaration from the inner context wins.

This is the opposite of the original scope proposal,
and means:

> ‚Ä¶normal declarations belonging to an encapsulation context
> can set defaults that are easily overridden by the outer context,
> while important declarations belonging to an encapsulation context
> can enforce requirements that cannot be overridden by the outer context.

[encapsulation context]: https://drafts.csswg.org/css-cascade-5/#cascade-context

#### The case for less isolation, and weak proximity

I have intentionally gone in the other direction,
making scope proximity _less powerful_ than specificity
in the cascade.
There is clearly interest in both strong & weak approaches to scope,
but I believe encapsulation context
can be expanded and improved on
for the high-isolation use-cases.
Meanwhile low-isolation scope has not been addressed.

By placing _scope proximity_
below/after specificity in the cascade,
I am explicitly & intentionally allowing
more global styles to flow through,
interact with,
and even override scoped styles:

```css
@‚Äãscope (aside) {
  p { color: green; }
}

aside#sidebar p { color: red; }
```

```html
<aside id="sidebar">
	<p>This is red</p>
</aside>
```

The primary use-case that I'm trying to address
is one in which component-styles are "locked-in"
to avoid cross-contamination,
but global styles are used to "tie it all together"
with consistent patterns like typography and branding.
The desired behavior is to prevent scoped styles from leaking out,
without getting in the way of global patterns
that should flow through easily.

If we give scope proximity more weight than specificity,
authors are left with very few tools to manage that relationship.
By putting proximity _below_ specificity,
authors can manage it in several ways:

- Adjust specificity to reflect desired priority,
  with equal specificity to trigger _proximity_ results
- Add lower boundaries to avoid overlap of styles

This _in-but-not-out_ approach
also matches the existing JS tools & CSS naming conventions
that authors already use.
Those tools add lower-boundaries,
and a single attribute-selector of increased specificity --
very easy to override from the global scope.
I think this low-weight approach to scope is also backed up by‚Ä¶

- much of the [long-running conversation on CSSWG][bring back scope]
- a [quick informal survey on Twitter][survey]
- Nicole Sullivan's [explainer from a couple years ago][nicole-scope]

Anecdotally,
I hear many CSS beginners surprised
that the fallback for specificity
is source-order rather than proximity.
This proposal would allow authors to opt-into
that expected proximity-over-source-order fallback behavior.

Meanwhile,
encapsulation could be expanded
for [use in the light DOM][isolation],
and proposal would continue to be distinct --
covering a significantly different set of use-cases.

[survey]: https://twitter.com/mirisuzanne/status/1351247559738621952
[isolation]: https://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharinghttps://docs.google.com/document/d/1hhjmuQE6BTTnAyKP3spDr8sU6lpXArh8LDfihZh78hw/edit?usp=sharing
[nicole-scope]: https://docs.google.com/presentation/d/1Ki-IUCEWU-mNlS-019QVV9I9JsytvafQJHTxpBNfYvI/edit?usp=sharing

#### Additional specificity

[Sara Soueidan has proposed][scope-id]
giving `@scope` the selector-weight of an `#ID`.
That would acknowledge the targeting weight of scopes,
without making them override all specificity.
I can see the thought behind it,
but that would not be flexible
or match existing behavior in any way.

[scope-id]: https://twitter.com/sarasoueidan/status/1351248295969103873?s=21

### Can we improve on the syntax?

The syntax could use some discussion,
especially around the proper label for lower boundaries.
There has been discussion of other keywords like `until`,
as well as a function syntax (eg `to(<selector>)`).
I'd also consider rephrasing to label these as "slots"
rather than "end-points":

```css
@scope root(.media-block) slots(.content) { /* ... */ }
```

## Spec History & Context

Besides the tooling that has developed,
there are several current & former specs
that are relevant here...

### CSS Scoping

- [First Public Working Draft][initial-spec]
- [Editors Draft](https://drafts.csswg.org/css-scoping/)

There is often pushback to the question of scope,
since the initial specification was never implemented,
and Shadow DOM was seen as a path forward.
While the current editors draft
is primarily concerned with Custom Elements & Shadow DOM,
this spec initially contained a full set of scoping features
that have since been removed:

A `<style scoped>` attribute,
which would apply styles
scoped to a particular DOM sub-tree.
This had a few limitations:

- Authors need to repeat styles in the DOM for every instance of the scope
- Those style need to live in distinct stylesheets

The use-cases that necessitate that approach
are now being handled by shadow encapsulation,
which frees us up to consider different use-cases now.

The spec also included `@scope` blocks in CSS,
which would help alleviate both issues.
Scoping has two primary effects:

1. The selector of the scoped style rule
   is restricted to match only elements within a subtree of the DOM
2. The cascade prioritizes scoped rules over un-scoped ones,
   regardless of specificity
3. Important declarations would flip the cascade order of scopes

Point 1 is limited by the need for lower scope boundaries,
or "donut scope".

Points 2 & 3 give scope _significant_ power in the cascade --
power that we now plan to provide through Cascade Layers.
While there are instances where the semantics of
layering, scoping, and containment
might reasonably overlap --
I think all three features are better off
with their own syntax.

In my proposal,
scope is only given a _minimal_ role in the cascade,
and mostly acts as a protection from naming conflicts.

### [CSS Selectors - Level 4](https://www.w3.org/TR/selectors-4/)

- [Scoped Selectors](https://www.w3.org/TR/selectors-4/#scoping),
  which only refer to a subtree or fragment of the document
- [Reference Element][scope-class]
  (`:scope`) pseudo-class ":scope elements" or the root of any scope
  (currently used in JS APIs only)

[scope-class]: https://www.w3.org/TR/selectors-4/#the-scope-pseudo

### [CSS Cascade - Level 4](https://www.w3.org/TR/css-cascade-4/)

- [Removes](https://www.w3.org/TR/css-cascade-4/#change-2018-drop-scoped)
  ‚Äúscoping‚Äù from the cascade sort criteria,
  because it has not been implemented.
- Adds [encapsulation context](https://www.w3.org/TR/css-cascade-4/#cascade-context)
  to the cascade, for handling Shadow DOM
  - Outer context wins for *normal* layer conflicts
  - Inner context wins for `!important` layer conflicts

## Stakeholder Feedback / Opposition

- Chromium : Positive --
  Google was involved in developing this proposal
- Gecko : No signals
- Webkit : No signals

## References & acknowledgements

Related/previous issues and discussions:

- [Bring Back Scope][]:
  - [@scope with lower-bounds](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-524206816)
  - [@scope with name & attribute](https://github.com/w3c/csswg-drafts/issues/3547#issuecomment-693022720)
- [Selector Boundaries](https://github.com/w3c/csswg-drafts/issues/5057)
- [CSS Namespaces](https://github.com/w3c/csswg-drafts/issues/270)
  ([priorities](https://github.com/w3c/csswg-drafts/issues/270#issuecomment-231586786))

[Bring Back Scope]: https://github.com/w3c/csswg-drafts/issues/3547

In addition to the open issue threads mentioned above,
thanks for valuable feedback and advice from:

- Anders Hartvoll Ruud
- Giuseppe Gurgone
- Ian Kilpatrick
- Keith Grant
- Kenneth Rohde Christiansen
- Lea Verou
- Mason Freed
- Nicole Sullivan
- Rune Lillesveen
- Sara Soueidan
- Tab Atkins
- Theresa O'Connor
- Una Kravets
- Yu Han

## To Be Addressed

Some questions that have been raised,
but I have not had a chance to address --
and they need more consideration:

From [Rune Lillesveen](https://github.com/w3ctag/design-reviews/issues/593#issuecomment-768992509)‚Ä¶

- Are `:host`, `::slotted`, and `::part` allowed in scope root selectors?
- Can tree-abiding pseudo elements (like `::before`) be scope roots?

## Change log

### 2021.01.29

- CLARIFY reasons for using `:scope` rather than `&`

### 2021.01.28

- NEW: Add proposal for `:in()` donut-scope selector
- CHANGE: Update specificity definition to reflect pseudo-class alternative
- CHANGE: Remove `&` syntax, to avoid conflicts with nesting
- Detailed discussion of selector syntax
- Detailed discussion of JS API for fetching a donut scope
- Detailed discussion of scope-nesting

### 2021.01.27

- CHANGE: Follow the [nesting module][nesting] rules
  for combining specificity of the scope selector
  with specificity of nested/scoped selectors.
- CHANGE: Allow [nesting module][nesting] syntax
  to be used [in scoped selectors](#the--nesting-selector)
- CLARIFY: The scope-root is prepended (as an ancestor)
  to all scoped selectors
  unless explicitly placed by use of `&` or `:scope`
- CLARIFY: The placement of
  [scope in the cascade](#where-does-scope-fit-in-the-cascade),
  and my reasons for allowing specificity
  to flow-through scopes in a single direction

### 2021.01.18

- Update acknowledgements
- CHANGE: Require `:scope` pseudo-class in scoped selectors that reference
  [context outside of the scope](#can-scoped-selectors-reference-external-context)
- CLARIFY: Shadow DOM behavior (scope respects shadow boundaries)
- CLARIFY: question about selector-lists in scope-root syntax
- CLARIFY: consistently use parenthesis around scope-root selectors
- CLARIFY: additional discussion of scope in the cascade
- CLARIFY: fix typo in proximity example
